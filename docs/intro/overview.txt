==================
初探 Django
==================

由于Django是在一个快节奏的新闻编辑室环境下开发出来的，因此它被设计成让普通的网站开发工作简单而快
捷。以下简单介绍了如何用 Django 编写一个数据库驱动的Web应用程序。

本文档的目标是给你描述足够的技术细节能让你理解Django是如何工作的，但是它并不表示是一个新手指南或参考目录
-- 其实这些我们都有!当你准备新建一个项目，你可以 :doc:`从新手指南开始 </intro/tutorial01>` 或者 :doc:`深入阅读详细的文档 </topics/index>` 。

设计你的模型(model)
=================

尽管你在 Django 中可以不使用数据库，但是它提供了一个完善的可以用 Python
代码描述你的数据库结构的 `对象关联映射(ORM)`_ 。

.. _对象关联映射(ORM): http://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84

:doc:`数据模型语法 </topics/db/models>` 提供了许多丰富的方法来展现你的模型 -- 
到目前为止，它已经解决了两个多年积累下来数据库架构问题。
下面是个简单的例子，可能被保存为 ``mysite/news/models.py``::

    from django.db import models

    class Reporter(models.Model):
        full_name = models.CharField(max_length=70)

        # On Python 3: def __str__(self):
        def __unicode__(self):
            return self.full_name

    class Article(models.Model):
        pub_date = models.DateField()
        headline = models.CharField(max_length=200)
        content = models.TextField()
        reporter = models.ForeignKey(Reporter)

        # On Python 3: def __str__(self):
        def __unicode__(self):
            return self.headline

安装你的模型
============

下一步，运行 Django 命令行工具来自动创建数据库表：

.. code-block:: bash

    $ python manage.py syncdb

:djadmin:`syncdb` 命令会查找你所有可用的模型(models)然后在你的数据库中创建还不存在的数据库表。

享用便捷的 API
==================

接着，你就可以使用一个便捷且功能丰富的 :doc:`Python API </topics/db/queries>`
来访问你的数据。API 是动态生成的，不需要代码生成:

.. code-block:: python

    # 导入我们在 "news "应用中创建的模型。
    >>> from news.models import Reporter, Article

    # 在系统中还没有 reporters 。
    >>> Reporter.objects.all()
    []

    # 创建一个新的 reporter 。
    >>> r = Reporter(full_name='John Smith')

    #将对象保存到数据库。你需要显式的调用 save() 方法。
    >>> r.save()

    # 现在它拥有了一个ID。
    >>> r.id
    1

    # 现在新的 reporter 已经存在数据库里了。
    >>> Reporter.objects.all()
    [<Reporter: John Smith>]

    # 字段被表示为一个 Python 对象的属性。
    >>> r.full_name
    'John Smith'

    # Django 提供了丰富的数据库查询 API。
    >>> Reporter.objects.get(id=1)
    <Reporter: John Smith>
    >>> Reporter.objects.get(full_name__startswith='John')
    <Reporter: John Smith>
    >>> Reporter.objects.get(full_name__contains='mith')
    <Reporter: John Smith>
    >>> Reporter.objects.get(id=2)
    Traceback (most recent call last):
        ...
    DoesNotExist: Reporter matching query does not exist. Lookup parameters were {'id': 2}

    # 创建一个 article.
    >>> from datetime import date
    >>> a = Article(pub_date=date.today(), headline='Django is cool',
    ...     content='Yeah.', reporter=r)
    >>> a.save()

    # 现在 article 已经存在数据库里了。
    >>> Article.objects.all()
    [<Article: Django is cool>]

    # Article 对象有 API 可以访问到关联到 Reporter 对象。
    >>> r = a.reporter
    >>> r.full_name
    'John Smith'

    # 反之亦然：Reporter 对象也有访问 Article 对象的API。
    >>> r.article_set.all()
    [<Article: Django is cool>]

    # API 会在幕后高效的关联表来满足你的关联查询的需求。
    # 以下例子是找出名字开头为 "John" 的 reporter 的所有 articles 。
    >>> Article.objects.filter(reporter__full_name__startswith="John")
    [<Article: Django is cool>]

    # 通过更改一个对象的属性值，然后再调用 save() 方法来改变它。
    >>> r.full_name = 'Billy Goat'
    >>> r.save()

    # 调用 delete() 方法来删除一个对象。
    >>> r.delete()

A dynamic admin interface: it's not just scaffolding -- it's the whole house
============================================================================

Once your models are defined, Django can automatically create a professional,
production ready :doc:`administrative interface </ref/contrib/admin/index>` --
a Web site that lets authenticated users add, change and delete objects. It's
as easy as registering your model in the admin site::

    # In models.py...

    from django.db import models

    class Article(models.Model):
        pub_date = models.DateField()
        headline = models.CharField(max_length=200)
        content = models.TextField()
        reporter = models.ForeignKey(Reporter)


    # In admin.py in the same directory...

    import models
    from django.contrib import admin

    admin.site.register(models.Article)

The philosophy here is that your site is edited by a staff, or a client, or
maybe just you -- and you don't want to have to deal with creating backend
interfaces just to manage content.

One typical workflow in creating Django apps is to create models and get the
admin sites up and running as fast as possible, so your staff (or clients) can
start populating data. Then, develop the way data is presented to the public.

Design your URLs
================

A clean, elegant URL scheme is an important detail in a high-quality Web
application. Django encourages beautiful URL design and doesn't put any cruft
in URLs, like ``.php`` or ``.asp``.

To design URLs for an app, you create a Python module called a :doc:`URLconf
</topics/http/urls>`. A table of contents for your app, it contains a simple
mapping between URL patterns and Python callback functions. URLconfs also serve
to decouple URLs from Python code.

Here's what a URLconf might look like for the ``Reporter``/``Article``
example above::

    from django.conf.urls import patterns

    urlpatterns = patterns('',
        (r'^articles/(\d{4})/$', 'news.views.year_archive'),
        (r'^articles/(\d{4})/(\d{2})/$', 'news.views.month_archive'),
        (r'^articles/(\d{4})/(\d{2})/(\d+)/$', 'news.views.article_detail'),
    )

The code above maps URLs, as simple `regular expressions`_, to the location of
Python callback functions ("views"). The regular expressions use parenthesis to
"capture" values from the URLs. When a user requests a page, Django runs
through each pattern, in order, and stops at the first one that matches the
requested URL. (If none of them matches, Django calls a special-case 404 view.)
This is blazingly fast, because the regular expressions are compiled at load
time.

.. _regular expressions: http://docs.python.org/2/howto/regex.html

Once one of the regexes matches, Django imports and calls the given view, which
is a simple Python function. Each view gets passed a request object --
which contains request metadata -- and the values captured in the regex.

For example, if a user requested the URL "/articles/2005/05/39323/", Django
would call the function ``news.views.article_detail(request,
'2005', '05', '39323')``.

Write your views
================

Each view is responsible for doing one of two things: Returning an
:class:`~django.http.HttpResponse` object containing the content for the
requested page, or raising an exception such as :class:`~django.http.Http404`.
The rest is up to you.

Generally, a view retrieves data according to the parameters, loads a template
and renders the template with the retrieved data. Here's an example view for
``year_archive`` from above::

    from django.shortcuts import render_to_response

    def year_archive(request, year):
        a_list = Article.objects.filter(pub_date__year=year)
        return render_to_response('news/year_archive.html', {'year': year, 'article_list': a_list})

This example uses Django's :doc:`template system </topics/templates>`, which has
several powerful features but strives to stay simple enough for non-programmers
to use.

Design your templates
=====================

The code above loads the ``news/year_archive.html`` template.

Django has a template search path, which allows you to minimize redundancy among
templates. In your Django settings, you specify a list of directories to check
for templates with :setting:`TEMPLATE_DIRS`. If a template doesn't exist in the
first directory, it checks the second, and so on.

Let's say the ``news/year_archive.html`` template was found. Here's what that
might look like:

.. code-block:: html+django

    {% extends "base.html" %}

    {% block title %}Articles for {{ year }}{% endblock %}

    {% block content %}
    <h1>Articles for {{ year }}</h1>

    {% for article in article_list %}
        <p>{{ article.headline }}</p>
        <p>By {{ article.reporter.full_name }}</p>
        <p>Published {{ article.pub_date|date:"F j, Y" }}</p>
    {% endfor %}
    {% endblock %}

Variables are surrounded by double-curly braces. ``{{ article.headline }}``
means "Output the value of the article's headline attribute." But dots aren't
used only for attribute lookup: They also can do dictionary-key lookup, index
lookup and function calls.

Note ``{{ article.pub_date|date:"F j, Y" }}`` uses a Unix-style "pipe" (the "|"
character). This is called a template filter, and it's a way to filter the value
of a variable. In this case, the date filter formats a Python datetime object in
the given format (as found in PHP's date function).

You can chain together as many filters as you'd like. You can write :ref:`custom
template filters <howto-writing-custom-template-filters>`. You can write
:doc:`custom template tags </howto/custom-template-tags>`, which run custom
Python code behind the scenes.

Finally, Django uses the concept of "template inheritance": That's what the
``{% extends "base.html" %}`` does. It means "First load the template called
'base', which has defined a bunch of blocks, and fill the blocks with the
following blocks." In short, that lets you dramatically cut down on redundancy
in templates: each template has to define only what's unique to that template.

Here's what the "base.html" template, including the use of :doc:`static files
</howto/static-files/index>`, might look like:

.. code-block:: html+django

    {% load staticfiles %}
    <html>
    <head>
        <title>{% block title %}{% endblock %}</title>
    </head>
    <body>
        <img src="{% static "images/sitelogo.png" %}" alt="Logo" />
        {% block content %}{% endblock %}
    </body>
    </html>

Simplistically, it defines the look-and-feel of the site (with the site's logo),
and provides "holes" for child templates to fill. This makes a site redesign as
easy as changing a single file -- the base template.

It also lets you create multiple versions of a site, with different base
templates, while reusing child templates. Django's creators have used this
technique to create strikingly different cell-phone editions of sites -- simply
by creating a new base template.

Note that you don't have to use Django's template system if you prefer another
system. While Django's template system is particularly well-integrated with
Django's model layer, nothing forces you to use it. For that matter, you don't
have to use Django's database API, either. You can use another database
abstraction layer, you can read XML files, you can read files off disk, or
anything you want. Each piece of Django -- models, views, templates -- is
decoupled from the next.

This is just the surface
========================

This has been only a quick overview of Django's functionality. Some more useful
features:

* A :doc:`caching framework </topics/cache>` that integrates with memcached
  or other backends.

* A :doc:`syndication framework </ref/contrib/syndication>` that makes
  creating RSS and Atom feeds as easy as writing a small Python class.

* More sexy automatically-generated admin features -- this overview barely
  scratched the surface.

The next obvious steps are for you to `download Django`_, read :doc:`the
tutorial </intro/tutorial01>` and join `the community`_. Thanks for your
interest!

.. _download Django: https://www.djangoproject.com/download/
.. _the community: https://www.djangoproject.com/community/
